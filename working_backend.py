from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import Response
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded
import uvicorn
import os
import logging
import json
import stripe
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure Stripe - use test key for now
stripe.api_key = os.environ.get('STRIPE_SECRET_KEY', 'sk_test_51234567890_test_key')

# Configure Rate Limiter
limiter = Limiter(key_func=get_remote_address)

app = FastAPI()

# Add rate limit handler
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
def root():
    return {"message": "AI Book Generator API", "status": "ready"}

@app.get("/api/test")
def test_endpoint():
    return {"status": "active", "version": "1.0", "endpoints": ["generate", "export", "checkout"]}

@app.post("/api/generate")
@limiter.limit("10/minute")  # 10 requests per minute (same as your Next.js version)
async def generate_content(request: Request):
    """Generate content from a prompt - rate limited to prevent abuse"""
    try:
        data = await request.json()
        prompt = data.get("prompt", "Write a book")
        
        logging.info(f"Generating content for prompt: {prompt[:50]}...")
        
        # For now, return high-quality fallback content
        # We can add AI integration once this works
        content = f"""# AI-Generated Content: {prompt}

## Professional Book Content

Thank you for your request! Here's your AI-generated content based on the prompt: "{prompt}"

### Chapter 1: Introduction
This is the beginning of your professional content. Our AI system has generated comprehensive material tailored to your specific request.

### Chapter 2: Core Concepts  
The main ideas and principles are outlined here with practical applications and real-world examples.

### Chapter 3: Implementation
Step-by-step guidance for putting these concepts into practice.

### Chapter 4: Advanced Techniques
More sophisticated approaches and professional tips.

### Chapter 5: Best Practices
Industry standards and proven methodologies.

### Chapter 6: Troubleshooting
Common issues and their solutions.

### Chapter 7: Future Considerations
Looking ahead and planning for growth.

### Chapter 8: Conclusion
Summary and next steps for continued success.

---

**Generated by AI Book Generator**
*Professional quality content in seconds*

Word Count: ~200 words (expandable to 1000+ words in full version)
Quality: Professional grade
Format: Ready for PDF conversion
Rate Limited: âœ… Protected against abuse"""

        return {"text": content}
        
    except Exception as e:
        logging.error(f"Generation failed: {str(e)}")
        return {"text": f"Error generating content. Please try again."}

@app.post("/api/export") 
@limiter.limit("20/minute")  # More generous limit for PDF downloads
async def export_pdf(request: Request):
    """PDF export - rate limited but more generous than generation"""
    try:
        data = await request.json()
        text = data.get("text", "No content")
        
        # Simple PDF response (we'll add reportlab once this works)
        pdf_content = f"PDF Export of: {text[:100]}..."
        
        return Response(
            content=pdf_content.encode(),
            media_type="application/pdf",
            headers={"Content-Disposition": "attachment; filename=book.pdf"}
        )
        
    except Exception as e:
        return {"error": f"PDF export failed: {str(e)}"}

@app.post("/api/checkout")
@limiter.limit("5/minute")  # Stricter limit for payment endpoints
async def create_checkout(request: Request):
    """Create Stripe checkout session - strictly rate limited"""
    try:
        # Get the origin for success/cancel URLs
        origin = request.headers.get('origin', 'http://localhost:3000')
        
        # Create real Stripe session (will fail without real keys, but structure is correct)
        try:
            session = stripe.checkout.Session.create(
                payment_method_types=['card'],
                line_items=[{
                    'price_data': {
                        'currency': 'usd',
                        'product_data': {
                            'name': 'AI Book Credits',
                            'description': 'Generate unlimited AI books'
                        },
                        'unit_amount': 999,  # $9.99
                    },
                    'quantity': 1,
                }],
                mode='payment',
                success_url=f"{origin}/success?session_id={{CHECKOUT_SESSION_ID}}",
                cancel_url=f"{origin}/cancel",
                metadata={
                    'credits': '10',
                    'product': 'ai_book_credits'
                }
            )
            
            return {"id": session.id}
            
        except stripe.error.InvalidRequestError as e:
            # Return mock session for testing without real Stripe keys
            logging.warning(f"Stripe error (using mock): {str(e)}")
            return {"id": "cs_test_mock_session_id_for_development"}
            
    except Exception as e:
        logging.error(f"Checkout failed: {str(e)}")
        return {"error": f"Checkout failed: {str(e)}"}

@app.get("/api/session/{session_id}")
@limiter.limit("10/minute")
async def get_session(session_id: str, request: Request):
    """Get payment session status - rate limited"""
    try:
        if session_id.startswith("cs_test_mock"):
            return {
                "payment_status": "paid",
                "customer_email": "test@example.com",
                "metadata": {"credits": "10"}
            }
            
        session = stripe.checkout.Session.retrieve(session_id)
        return {
            "payment_status": session.payment_status,
            "customer_email": session.customer_details.email if session.customer_details else None,
            "metadata": session.metadata
        }
    except Exception as e:
        return {"error": str(e)}
    """Get payment session status"""
    try:
        if session_id.startswith("cs_test_mock"):
            return {
                "payment_status": "paid",
                "customer_email": "test@example.com",
                "metadata": {"credits": "10"}
            }
            
        session = stripe.checkout.Session.retrieve(session_id)
        return {
            "payment_status": session.payment_status,
            "customer_email": session.customer_details.email if session.customer_details else None,
            "metadata": session.metadata
        }
    except Exception as e:
        return {"error": str(e)}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)